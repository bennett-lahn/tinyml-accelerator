#!/usr/bin/env python3
"""
Generate exponential LUT values for the softmax unit.

This script generates a SystemVerilog-compatible initialization file
for the exponential lookup table used in the softmax acceleration unit.
Updated for int8 inputs with 0.0625 scaling factor.
"""

import math
import argparse
import os

def generate_exp_lut_hex_file(filename="exp_lut.hex"):
    """Generate 2^x LUT values as a hex file for $readmemh."""
    
    # LUT parameters
    lut_size = 256
    scale_factor = 0.0625  # Hardware scaling: int8 * 0.0625 = scaled float
    
    print(f"Generating hex file: {filename}")
    print(f"LUT size: {lut_size} entries")
    print(f"Scale factor: {scale_factor}")
    print("Using 2^x instead of exp(x) for hardware efficiency")
    print("")
    
    # First pass: calculate all 2^x values to determine scaling strategy
    pow2_values = []
    for i in range(lut_size):
        # Convert LUT index to signed int8 value
        if i >= 128:
            signed_val = i - 256  # Convert to signed int8
        else:
            signed_val = i
            
        # Apply hardware scaling
        x = signed_val * scale_factor
        
        # Calculate 2^x instead of exp(x)
        pow2_x = 2.0 ** x
        pow2_values.append(pow2_x)
    
    # Find min and max 2^x values for better scaling
    min_pow2 = min(pow2_values)
    max_pow2 = max(pow2_values)
    print(f"Min 2^x value: {min_pow2:.10f}")
    print(f"Max 2^x value: {max_pow2:.6f}")
    print(f"Dynamic range: {max_pow2/min_pow2:.2e}")
    
    # Use 32-bit unsigned integers for excellent dynamic range
    # For 2^x, we can use a more intuitive scaling approach
    max_32bit = 0xFFFFFFFF  # 4,294,967,295
    
    # Since we're using 2^x, let's use a fixed-point representation where:
    # - The stored value represents 2^x * 2^FRAC_BITS
    # - This allows us to use bit-shifting in hardware
    
    # Choose FRAC_BITS such that we use most of the 32-bit range
    # We want: max(2^x * 2^FRAC_BITS) â‰ˆ 2^31 (to stay within range)
    # So: FRAC_BITS = 31 - log2(max(2^x)) = 31 - max(x)
    
    max_x = max([signed_val * scale_factor for signed_val in range(-128, 128)])
    frac_bits = max(0, 31 - int(math.ceil(max_x)))
    pow2_scale_factor = 2 ** frac_bits
    
    print(f"Max x value: {max_x:.3f}")
    print(f"Using {frac_bits} fractional bits for fixed-point representation")
    print(f"Scale factor: 2^{frac_bits} = {pow2_scale_factor}")
    print(f"Scaled max 2^x: {max_pow2 * pow2_scale_factor:.0f}")
    print("")
    
    # Generate LUT values
    lut_values = []
    
    for i in range(lut_size):
        # Convert LUT index to signed int8 value
        if i >= 128:
            signed_val = i - 256  # Convert to signed int8
        else:
            signed_val = i
            
        # Apply hardware scaling
        x = signed_val * scale_factor
        
        # Calculate 2^x
        pow2_x = 2.0 ** x
        
        # Scale to fixed-point representation
        scaled_pow2 = pow2_x * pow2_scale_factor
        
        # Convert to 32-bit unsigned integer
        if scaled_pow2 >= max_32bit:
            uint32_value = max_32bit
        else:
            uint32_value = int(round(scaled_pow2))
            if uint32_value < 0:
                uint32_value = 0
        
        lut_values.append((i, signed_val, x, pow2_x, scaled_pow2, uint32_value))
    
    # Write hex file (32-bit values)
    with open(filename, 'w') as f:
        # Write header comment
        f.write(f"// 2^x LUT for Softmax Unit (32-bit values)\n")
        f.write(f"// Generated by generate_exp_lut.py\n")
        f.write(f"// Format: 32-bit unsigned integers (fixed-point)\n")
        f.write(f"// Scale factor: {scale_factor} (int8 * 0.0625)\n")
        f.write(f"// Fixed-point scale: 2^{frac_bits} = {pow2_scale_factor}\n")
        f.write(f"// Index mapping: LUT[i] = 2^((i >= 128 ? i-256 : i) * 0.0625) * 2^{frac_bits}\n")
        f.write(f"// Total entries: {lut_size}\n")
        f.write(f"// Dynamic range preserved: {max_pow2/min_pow2:.2e}\n")
        f.write(f"// Hardware usage: value >> {frac_bits} gives integer part, value & 0x{(2**frac_bits-1):X} gives fractional part\n")
        f.write(f"//\n")
        
        # Write values in hex format (32-bit, one per line for $readmemh)
        for i, (idx, signed_val, x, pow2_x, scaled_pow2, uint32_value) in enumerate(lut_values):
            f.write(f"{uint32_value:08X}\n")
    
    # Print verification info
    print(f"Hex file '{filename}' generated successfully!")
    print(f"Total entries: {lut_size}")
    print("Format: 32-bit unsigned integers (8 hex digits per line)")
    print("")
    
    # Print key verification points
    print("Key verification points:")
    key_points = [0, 32, 64, 96, 128, 160, 192, 224, 255]
    for idx in key_points:
        if idx < len(lut_values):
            _, signed_val, x, pow2_x, scaled_pow2, uint32_value = lut_values[idx]
            print(f"  LUT[{idx:3d}]: int8={signed_val:4d}, x={x:6.3f}, 2^x={pow2_x:8.6f}, scaled={scaled_pow2:.0f}, hex=0x{uint32_value:08X}")
    
    print("")
    print("SystemVerilog usage (32-bit):")
    print("  logic [31:0] exp_lut [255:0];")
    print("  initial begin")
    print(f"    $readmemh(\"{filename}\", exp_lut);")
    print("  end")
    print("")
    print(f"Hardware scaling info:")
    print(f"  - LUT stores: 2^(int8_value * 0.0625) * 2^{frac_bits}")
    print(f"  - To get original 2^x: lut_value >> {frac_bits} (with {frac_bits}-bit fractional part)")
    print(f"  - For softmax: use lut_values directly, scaling cancels out in ratios")
    print(f"  - Much more hardware-friendly than exp(x)!")
    print("")
    
    return lut_values, frac_bits

def generate_exp_lut():
    """Generate 2^x LUT values in Q1.31 format for int8 inputs."""
    
    # LUT parameters
    lut_size = 256
    scale_factor = 0.0625  # Hardware scaling: int8 * 0.0625 = scaled float
    
    print(f"// 2^x LUT generated for int8 range [-128, 127]")
    print(f"// Scale factor: {scale_factor} (maps int8 to approximately [-8, 8])")
    print(f"// Format: 32-bit unsigned integers (fixed-point)")
    print(f"// Generated by generate_exp_lut.py")
    print("")
    
    # First pass: calculate all 2^x values to determine scaling strategy
    pow2_values = []
    for i in range(lut_size):
        # Convert LUT index to signed int8 value
        if i >= 128:
            signed_val = i - 256  # Convert to signed int8
        else:
            signed_val = i
            
        # Apply hardware scaling
        x = signed_val * scale_factor
        
        # Calculate 2^x instead of exp(x)
        pow2_x = 2.0 ** x
        pow2_values.append(pow2_x)
    
    # Find min and max 2^x values for better scaling
    min_pow2 = min(pow2_values)
    max_pow2 = max(pow2_values)
    print(f"// Min 2^x value: {min_pow2:.10f}")
    print(f"// Max 2^x value: {max_pow2:.6f}")
    print(f"// Dynamic range: {max_pow2/min_pow2:.2e}")
    
    # Use the same scaling approach as the hex file generation
    max_x = max([signed_val * scale_factor for signed_val in range(-128, 128)])
    frac_bits = max(0, 31 - int(math.ceil(max_x)))
    pow2_scale_factor = 2 ** frac_bits
    
    print(f"// Max x value: {max_x:.3f}")
    print(f"// Using {frac_bits} fractional bits for fixed-point representation")
    print(f"// Scale factor: 2^{frac_bits} = {pow2_scale_factor}")
    print("")
    
    # Generate LUT values
    lut_values = []
    
    for i in range(lut_size):
        # Convert LUT index to signed int8 value
        if i >= 128:
            signed_val = i - 256  # Convert to signed int8
        else:
            signed_val = i
            
        # Apply hardware scaling
        x = signed_val * scale_factor
        
        # Calculate 2^x
        pow2_x = 2.0 ** x
        
        # Scale to fixed-point representation
        scaled_pow2 = pow2_x * pow2_scale_factor
        
        # Convert to 32-bit unsigned integer
        max_32bit = 0xFFFFFFFF
        if scaled_pow2 >= max_32bit:
            uint32_value = max_32bit
        else:
            uint32_value = int(round(scaled_pow2))
            if uint32_value < 0:
                uint32_value = 0
        
        lut_values.append((i, signed_val, x, pow2_x, scaled_pow2, uint32_value))
        
        # Print every 32nd entry for verification
        if i % 32 == 0:
            print(f"// LUT[{i:3d}]: int8={signed_val:4d}, x={x:6.3f}, 2^x={pow2_x:8.6f}, scaled={scaled_pow2:8.6f}, Q32=0x{uint32_value:08X}")
    
    print("")
    print("// SystemVerilog initialization code:")
    print("initial begin")
    
    # Print in groups of 4 for readability (32-bit values are longer)
    for i in range(0, lut_size, 4):
        line = "    "
        for j in range(4):
            if i + j < lut_size:
                idx = i + j
                _, signed_val, _, _, _, uint32_value = lut_values[idx]
                line += f"exp_lut[{idx:3d}] = 32'h{uint32_value:08X}; "
        print(line)
    
    print("end")
    print("")
    
    # Generate a more compact initialization for direct copy-paste
    print("// Compact initialization (copy this into your SystemVerilog module):")
    print("logic [31:0] exp_lut_values [255:0] = '{")
    
    for i in range(0, lut_size, 4):
        line = "    "
        for j in range(4):
            if i + j < lut_size:
                idx = i + j
                _, signed_val, _, _, _, uint32_value = lut_values[idx]
                line += f"32'h{uint32_value:08X}"
                if idx < lut_size - 1:
                    line += ", "
                if (j == 3 or idx == lut_size - 1) and idx < lut_size - 1:
                    line += " //"
                    for k in range(max(0, j-3), j+1):
                        if i + k < lut_size:
                            _, sv, _, _, _, _ = lut_values[i + k]
                            line += f" {sv:3d}"
        print(line)
    
    print("};")
    print("")
    print("// Then in your initial block:")
    print("initial begin")
    print("    exp_lut = exp_lut_values;")
    print("end")

def compute_softmax(logits, beta=1.0):
    """Compute softmax in Python for verification."""
    scale_factor = 0.0625  # Same as hardware
    
    # Convert int8 to float using hardware scaling
    float_logits = [logit * scale_factor for logit in logits]
    
    # Apply beta scaling
    scaled_logits = [beta * x for x in float_logits]
    
    # Find max for numerical stability
    max_logit = max(scaled_logits)
    
    # Compute shifted exponentials (using 2^x to match hardware)
    pow2_values = [2.0 ** (x - max_logit) for x in scaled_logits]
    
    # Compute sum
    pow2_sum = sum(pow2_values)
    
    # Compute probabilities
    probabilities = [pow2_val / pow2_sum for pow2_val in pow2_values]
    
    return probabilities

def print_test_case(name, logits, probabilities):
    """Print a formatted test case."""
    print(f"// {name} Test Case:")
    print("// Input logits (int8):   ", logits)
    
    # Convert to float for display
    float_logits = [logit * 0.0625 for logit in logits]
    print("// Input logits (float):  ", [f"{x:6.3f}" for x in float_logits])
    
    print("// Expected probabilities:", [f"{x:6.4f}" for x in probabilities])
    
    # Convert to Q1.31 format (32-bit fixed point)
    q1_31_probs = []
    for p in probabilities:
        if p >= 1.0:
            q_val = 0x7FFFFFFF  # Maximum positive value in Q1.31
        elif p < 0:
            q_val = 0x80000000  # Most negative value in Q1.31
        else:
            # Convert to Q1.31: multiply by 2^31 and round
            q_val = int(p * 2147483648.0) & 0xFFFFFFFF
        q1_31_probs.append(q_val)
    
    print("// Expected probs (Q1.31):", [f"0x{x:08X}" for x in q1_31_probs])
    print(f"// Sum of probabilities: {sum(probabilities):.6f}")

def generate_test_vectors():
    """Generate test vectors for verification."""
    print("\n" + "="*60)
    print("Test Vectors for Softmax Verification (int8 inputs, Q1.31 outputs)")
    print("="*60)
    
    # Test case 1: Uniform logits
    print("\n// Test Case 1: Uniform logits (should give ~0.1 for each class)")
    logits = [0] * 10  # All zeros
    softmax_values = compute_softmax(logits)
    print_test_case("Uniform", logits, softmax_values)
    
    # Test case 2: One dominant class
    print("\n// Test Case 2: One dominant class")
    logits = [-32] * 10  # All -32 (corresponds to -2.0 in float)
    logits[5] = 48       # 48 corresponds to 3.0 in float
    softmax_values = compute_softmax(logits)
    print_test_case("Dominant", logits, softmax_values)
    
    # Test case 3: Ascending values
    print("\n// Test Case 3: Ascending values")
    logits = [-64 + i * 8 for i in range(10)]  # From -64 to +8 in steps of 8
    softmax_values = compute_softmax(logits)
    print_test_case("Ascending", logits, softmax_values)
    
    # Test case 4: Extreme values
    print("\n// Test Case 4: Extreme values")
    logits = [-128] * 9 + [127]  # All minimum except one maximum
    softmax_values = compute_softmax(logits)
    print_test_case("Extreme", logits, softmax_values)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generate exponential LUT for softmax unit')
    parser.add_argument('--hex-file', '-f', default='exp_lut.hex', 
                       help='Output hex file name (default: exp_lut.hex)')
    parser.add_argument('--hex-only', action='store_true',
                       help='Generate only hex file, skip SystemVerilog output')
    parser.add_argument('--sv-only', action='store_true', 
                       help='Generate only SystemVerilog output, skip hex file')
    
    args = parser.parse_args()
    
    print("Exponential LUT Generator for Softmax Unit (int8 inputs)")
    print("=" * 60)
    
    if not args.sv_only:
        print("Generating hex file...")
        print("-" * 30)
        generate_exp_lut_hex_file(args.hex_file)
    
    if not args.hex_only:
        print("Generating SystemVerilog code...")
        print("-" * 30)
        generate_exp_lut()
        generate_test_vectors()
